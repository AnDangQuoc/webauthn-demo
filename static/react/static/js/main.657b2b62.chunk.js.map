{"version":3,"sources":["webAuthAPI.js","App.js","utils/oids.js","serviceWorker.js","index.js","utils/utils.js","utils/output-parser.js","utils/transformations.js","utils.js"],"names":["registerV2","body","fetch","method","credentials","headers","JSON","stringify","then","response","json","status","Error","message","loginV2","TabPane","Tabs","layout","labelCol","span","wrapperCol","tailLayout","offset","App","state","options","user","challenge","getResponse","clientData","handleRegister","values","a","username","name","alert","setState","createWebauthConfig","navigator","create","console","log","jsonBody","publicKeyCredentialToJSON","window","dev1","res","parseAttestationObject","attestationObject","attestation","publicKeyCredential","error","handleLogin","username2","createWebauthGetConfig","get","response2","dev2","parse","parseCredentials","success","PublicKeyCredential","isUserVerifyingPlatformAuthenticatorAvailable","parseAuthenticatorData","base64url","derToPem","dev","crypto","buff","Buffer","displayName","Uint8Array","userId","getRandomValues","publicKey","rp","id","authenticatorSelection","authenticatorAttachment","pubKeyCredParams","type","alg","this","allowCredientails","rawId","transports","credential","decodedClientData","TextDecoder","decode","clientDataJSON","clientDataObj","authData","cbor","decodeAllSync","dataView","DataView","ArrayBuffer","slice","forEach","value","index","setUint8","credentialIdLength","getUint16","publicKeyBytes","publicKeyObject","buffer","data","authenticatorData","toBuffer","userHandle","className","tab","key","style","display","alignItems","justifyContent","onFinish","Item","label","rules","required","htmlType","form","raw","parsed","parseCreateCredentialResponse","parseGetCredentialResponse","React","Component","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister","catch","deepClone","object","result","Array","isArray","objectSlice","keys","transform","transformations","Object","der","b64","from","toString","withBreaks","i","length","prettyStringify","Encoder","genTypes","encoder","arrayBuffer","pushAny","d","byteOffset","byteLength","p","end","rpIdHash","getUint8","flags","userPresent","reserved1","userVerified","reserved2","attestedCredentialData","extensionDataIncluded","signCount","getUint32","atCredData","aaguid","credentialId","encodedCred","credentialPublicKey","encode","decodeFirstSync","e","decoded","msg","parseClientDataJSON","prettifyTransformations","binToHex","buttons","sig","signature","x5c","arr","map","coseToJwk","pubKeyCred","push","obj"],"mappings":"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","file":"static/js/main.657b2b62.chunk.js","sourcesContent":["import ky from \"ky\"\n\nexport function getMakeCredentialsChallenge(formBody) {\n  return fetch(\"/webauthn/register\", {\n    method: \"POST\",\n    credentials: \"include\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(formBody),\n  })\n    .then((response) => response.json())\n    .then((response) => {\n      if (response.status !== \"ok\")\n        throw new Error(\n          `Server responed with error. The message is: ${response.message}`\n        )\n\n      return response\n    })\n}\n\nexport function verifyResponse(body) {\n  return fetch(\"/webauthn/verify/v2\", {\n    method: \"POST\",\n    credentials: \"include\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(body),\n  })\n    .then((response) => response.json())\n    .then((response) => {\n      if (response.status !== \"ok\")\n        throw new Error(\n          `Server responed with error. The message is: ${response.message}`\n        )\n\n      return response\n    })\n}\n\nexport function registerV2(body) {\n  return fetch(\"/webauthn/register/v2\", {\n    method: \"POST\",\n    credentials: \"include\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(body),\n  })\n    .then((response) => response.json())\n    .then((response) => {\n      if (response.status !== \"ok\")\n        throw new Error(\n          `Server responed with error. The message is: ${response.message}`\n        )\n\n      return response\n    })\n}\n\nexport function loginV2(body) {\n  return fetch(\"/webauthn/login/v2\", {\n    method: \"POST\",\n    credentials: \"include\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(body),\n  })\n    .then((response) => response.json())\n    .then((response) => {\n      if (response.status !== \"ok\")\n        throw new Error(\n          `Server responed with error. The message is: ${response.message}`\n        )\n\n      return response\n    })\n}\n\nexport function getGetAssertionChallenge(formBody) {\n  return fetch(\"/webauthn/login\", {\n    method: \"POST\",\n    credentials: \"include\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(formBody),\n  })\n    .then((response) => response.json())\n    .then((response) => {\n      if (response.status !== \"ok\")\n        throw new Error(\n          `Server responed with error. The message is: ${response.message}`\n        )\n\n      return response\n    })\n}\n\nexport function sendWebAuthnResponse(body) {\n  return fetch(\"/webauthn/response\", {\n    method: \"POST\",\n    credentials: \"include\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(body),\n  })\n    .then((response) => response.json())\n    .then((response) => {\n      if (response.status !== \"ok\")\n        throw new Error(\n          `Server responed with error. The message is: ${response.message}`\n        )\n\n      return response\n    })\n}\n","import React from \"react\"\nimport { Card, Form, Input, Button, message, Tabs } from \"antd\"\nimport { JsonEditor as Editor } from \"jsoneditor-react\"\nimport \"jsoneditor-react/es/editor.min.css\"\nimport Terminal from \"react-console-emulator\"\n// import crypto from \"crypto-browserify\"\nimport cbor from \"cbor\"\n\nimport {\n  parseAuthenticatorData,\n  parseAttestationObject,\n  parseCredentials,\n} from \"./utils/output-parser\"\n\nimport { derToPem } from \"./utils/utils\"\n\nimport base64url from \"base64url\"\n\nimport {\n  getMakeCredentialsChallenge,\n  sendWebAuthnResponse,\n  getGetAssertionChallenge,\n  verifyResponse,\n  registerV2,\n  loginV2,\n} from \"./webAuthAPI\"\nimport {\n  preformatMakeCredReq,\n  publicKeyCredentialToJSON,\n  preformatGetAssertReq,\n  Base64Decode,\n} from \"./utils\"\n\nconst { TabPane } = Tabs\n\nconst layout = {\n  labelCol: { span: 8 },\n  wrapperCol: { span: 16 },\n}\nconst tailLayout = {\n  wrapperCol: { offset: 8, span: 16 },\n}\n\nclass App extends React.Component {\n  state = {\n    options: {},\n    user: {},\n    response: null,\n    challenge: \"\",\n    getResponse: null,\n    clientData: {},\n  }\n  async componentDidMount() {\n    const a = await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()\n    if (!a) {\n      message.error(\"Webauthnn not support\")\n    }\n\n    window.parseAttestationObject = parseAttestationObject\n    window.parseCredentials = parseCredentials\n    window.parseAuthenticatorData = parseAuthenticatorData\n    window.publicKeyCredentialToJSON = publicKeyCredentialToJSON\n    window.base64url = base64url\n    window.derToPem = derToPem\n    window.dev = crypto\n    window.buff = Buffer\n  }\n\n  createWebauthConfig(username, displayName) {\n    const challenge = new Uint8Array(32)\n    const userId = new Uint8Array(32)\n    crypto.getRandomValues(challenge)\n    crypto.getRandomValues(userId)\n\n    const options = {\n      publicKey: {\n        challenge: challenge,\n\n        rp: {\n          name: \"Webauthn Play\",\n          id: \"webauthnplay.herokuapp.com\",\n        },\n\n        user: {\n          id: userId,\n          name: username,\n          displayName: displayName,\n        },\n\n        attestation: \"direct\",\n\n        authenticatorSelection: { authenticatorAttachment: \"platform\" },\n        pubKeyCredParams: [\n          {\n            type: \"public-key\",\n            alg: -7, // \"ES256\" IANA COSE Algorithms registry\n          },\n        ],\n      },\n    }\n\n    this.setState({\n      challenge: challenge,\n      user: { id: userId, name: username, displayName: displayName },\n      options: options,\n    })\n    return options\n  }\n\n  createWebauthGetConfig() {\n    const { challenge, user, response } = this.state\n    if (response) {\n      return {\n        publicKey: {\n          challenge: challenge,\n          allowCredientails: [\n            {\n              type: \"public-key\",\n              id: response.rawId,\n              transports: [\"usb\", \"ble\", \"nfc\", \"internal\"],\n            },\n          ],\n        },\n      }\n    }\n  }\n\n  parseCreateCredentialResponse(credential) {\n    // Parse Client Data\n    const utf8Decoder = new TextDecoder(\"utf-8\")\n    const decodedClientData = utf8Decoder.decode(\n      credential.response.clientDataJSON\n    )\n\n    // parse the string as an object\n    const clientDataObj = JSON.parse(decodedClientData)\n\n    // Parse attestation Object\n    const decodedAttestationObject = cbor.decodeAllSync(\n      credential.response.attestationObject\n    )[0]\n\n    const { authData } = decodedAttestationObject\n\n    // get the length of the credential ID\n    const dataView = new DataView(new ArrayBuffer(2))\n    const idLenBytes = authData.slice(53, 55)\n    idLenBytes.forEach((value, index) => dataView.setUint8(index, value))\n    const credentialIdLength = dataView.getUint16()\n\n    // get the credential ID\n    const credentialId = authData.slice(55, 55 + credentialIdLength)\n\n    // get the public key object\n    const publicKeyBytes = authData.slice(55 + credentialIdLength)\n\n    // the publicKeyBytes are encoded again as CBOR\n    const publicKeyObject = cbor.decode(publicKeyBytes.buffer)\n\n    return { clientDataObj, publicKeyObject }\n  }\n\n  parseGetCredentialResponse(data) {\n    const clientData = JSON.parse(\n      base64url.decode(data.response.clientDataJSON)\n    )\n    const authenticatorData = parseAuthenticatorData(\n      base64url.toBuffer(data.response.authenticatorData)\n    )\n    const userHandle = base64url.decode(data.response.userHandle)\n    return { clientData, authenticatorData, userHandle }\n  }\n\n  handleRegister = async (values) => {\n    // event.preventDefault()\n    const { username, name = \"auto\" } = values\n\n    if (!username || !name) {\n      alert(\"Name or username is missing!\")\n      return\n    }\n    this.setState({})\n    const that = this\n\n    const options = this.createWebauthConfig(username, name)\n\n    try {\n      const response = await navigator.credentials.create(options)\n\n      console.log(\"create credential response\", response)\n      const jsonBody = publicKeyCredentialToJSON(response)\n      // console.log(\"Body 1\", jsonBody)\n\n      window.dev1 = response\n\n      // const res = await verifyResponse({\n      //   username: username,\n      //   webauthnResp: jsonBody,\n      // })\n\n      const res = parseAttestationObject(response.response.attestationObject)\n      console.log(\"parsed credential\", res)\n      this.setState({\n        response: publicKeyCredentialToJSON(response),\n        attestation: res,\n      })\n      await registerV2({\n        username,\n        name,\n        publicKeyCredential: jsonBody,\n      })\n    } catch (error) {\n      message.error(error.message)\n    }\n    // window.navigator.credentials\n    //   .create(options)\n    //   .then((response) => {\n    //     // let makeCredResponse =  publicKeyCredentialToJSON(response)\n    //     console.log(response)\n    //     // that.setState({ response: response })\n    //   })\n    //   .catch((error) => message(error))\n    // getMakeCredentialsChallenge({ username, name })\n    //   .then((response) => {\n    //     let publicKey = preformatMakeCredReq(response)\n    //     that.setState({ options: { publicKey } })\n    //     return window.navigator.credentials.create({ publicKey })\n    //   })\n    //   .then((response) => {\n    //     let makeCredResponse = publicKeyCredentialToJSON(response)\n    //     return sendWebAuthnResponse(makeCredResponse)\n    //   })\n    //   .then((response) => {\n    //     message.success(\"ok\")\n    //     // if (response.status === \"ok\") {\n    //     //   loadMainContainer()\n    //     // } else {\n    //     //   alert(\n    //     //     `Server responed with error. The message is: ${response.message}`\n    //     //   )\n    //     // }\n    //   })\n    //   .catch((error) => alert(error))\n  }\n\n  handleLogin = async (values) => {\n    let username = values.username2\n    const { response, attestation } = this.state\n    if (!response || !attestation) {\n      message.error(\"Not registered\")\n      return\n    }\n\n    if (!username) {\n      message.error(\"Username is missing!\")\n      return\n    }\n\n    const options = this.createWebauthGetConfig()\n\n    try {\n      const response2 = await navigator.credentials.get(options)\n      console.log(\"Get credieantial response\", response2)\n      window.dev2 = response2\n\n      this.setState({\n        getResponse: publicKeyCredentialToJSON(response2),\n        parse: parseCredentials(response2),\n      })\n\n      const jsonBody = publicKeyCredentialToJSON(response2)\n      await loginV2({ username, publicKeyCredential: jsonBody })\n\n      // const jsonTemp = publicKeyCredentialToJSON(response)\n      // jsonBody.response.attestationObject = jsonTemp.response.attestationObject\n      // console.log(\"Body 2\", jsonBody)\n\n      // const data = Buffer.concat([\n      //   base64url.toBuffer(response2.response.authenticatorData),\n      //   base64url.toBuffer(response2.response.clientDataJSON),\n      // ])\n\n      // const result = window.crypto\n      //   .createVerify(\"SHA256\")\n      //   .update(data)\n      //   .verify(\n      //     attestation.authData.attestedCredentialData.credentialPublicKey,\n      //     base64url.toBuffer(jsonBody.signature)\n      //   )\n\n      // return coseToJwk(\n      //   parsed.authData.attestedCredentialData.credentialPublicKey\n      // );\n      // const res = await verifyResponse({\n      //   username: username,\n      //   webauthnResp: jsonBody,\n      // })\n      message.success(\"OK\")\n    } catch (error) {\n      message.error(error.message)\n    }\n\n    // getGetAssertionChallenge({ username })\n    //   .then((response) => {\n    //     console.log(response)\n    //     let publicKey = preformatGetAssertReq(response)\n    //     that.setState({ options: { publicKey } })\n\n    //     return window.\n    //   })\n    //   .then((response) => {\n    //     console.log()\n    //     let getAssertionResponse = publicKeyCredentialToJSON(response)\n    //     return sendWebAuthnResponse(getAssertionResponse)\n    //   })\n    //   .then((response) => {\n    //     message.success(\"OK\")\n    //     console.log(response)\n    //     // if (response.status === \"ok\") {\n    //     //   loadMainContainer()\n    //     // } else {\n    //     //   alert(\n    //     //     `Server responed with error. The message is: ${response.message}`\n    //     //   )\n    //     // }\n    //   })\n    //   .catch((error) => alert(error))\n  }\n  render() {\n    const { options, user, response, challenge, getResponse } = this.state\n    return (\n      <div className=\"card-container\">\n        <Tabs type=\"card\">\n          <TabPane tab=\"Register\" key=\"1\">\n            <div\n              style={{\n                display: \"flex\",\n                alignItems: \"center\",\n                justifyContent: \"center\",\n              }}\n            >\n              <Form\n                onFinish={this.handleRegister}\n                {...layout}\n                id=\"form_register\"\n              >\n                <Form.Item\n                  label=\"User Name\"\n                  name=\"username\"\n                  rules={[\n                    { required: true, message: \"Please input your username!\" },\n                  ]}\n                >\n                  <Input></Input>\n                </Form.Item>\n                <Form.Item\n                  label=\"Name\"\n                  name=\"name\"\n                  rules={[\n                    { required: true, message: \"Please input your name!\" },\n                  ]}\n                >\n                  <Input></Input>\n                </Form.Item>\n                <Form.Item {...tailLayout}>\n                  <Button type=\"primary\" htmlType=\"submit\" form=\"form_register\">\n                    Register\n                  </Button>\n                </Form.Item>\n              </Form>\n            </div>\n          </TabPane>\n          <TabPane tab=\"Login\" key=\"2\">\n            <div\n              style={{\n                display: \"flex\",\n                alignItems: \"center\",\n                justifyContent: \"center\",\n              }}\n            >\n              <Form onFinish={this.handleLogin} id=\"form_update\">\n                <Form.Item\n                  label=\"User Name\"\n                  name=\"username2\"\n                  rules={[\n                    { required: true, message: \"Please input your username!\" },\n                  ]}\n                >\n                  <Input></Input>\n                </Form.Item>\n                <Form.Item {...tailLayout}>\n                  <Button type=\"primary\" htmlType=\"submit\" form=\"form_update\">\n                    Login\n                  </Button>\n                </Form.Item>\n              </Form>\n            </div>\n          </TabPane>\n        </Tabs>\n        {response ? (\n          <div>\n            {\" \"}\n            <p>Create Credential Response</p> <br></br>\n            <Editor\n              value={{\n                raw: response,\n                parsed: this.parseCreateCredentialResponse(response),\n              }}\n            ></Editor>\n          </div>\n        ) : (\n          <div />\n        )}\n        {getResponse ? (\n          <div>\n            <p>Get Credential Response</p> <br></br>\n            <Editor\n              value={{\n                raw: getResponse,\n                parsed: this.parseGetCredentialResponse(getResponse),\n              }}\n            ></Editor>\n          </div>\n        ) : (\n          <div></div>\n        )}\n      </div>\n    )\n  }\n}\nexport default App\n","export default {\n  '1.2.840.113549.1.1.11': 'sha256WithRSAEncryption'\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport \"antd/dist/antd.css\" // or 'antd/dist/antd.less'\n\nimport \"./index.css\"\nimport App from \"./App\"\nimport * as serviceWorker from \"./serviceWorker\"\n\nReactDOM.render(\n  // <React.StrictMode>\n  <App />,\n  // </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n","import oids from \"./oids.js\"\n\nimport { fromBER } from \"asn1js\"\nimport { Certificate } from \"pkijs\"\nimport cbor from \"cbor\"\n\nexport function deepClone(object) {\n  const result = {}\n\n  for (const key in object) {\n    const value = object[key]\n\n    if (typeof value === \"object\") {\n      if (\n        Array.isArray(value) ||\n        value instanceof ArrayBuffer ||\n        (value && \"length\" in value)\n      ) {\n        result[key] = value.slice()\n      } else {\n        result[key] = deepClone(value)\n      }\n    } else {\n      result[key] = value\n    }\n  }\n\n  return result\n}\n\nexport function objectSlice(object, keys) {\n  const result = {}\n  for (const key of keys) {\n    if (key in object) {\n      result[key] = object[key]\n    }\n  }\n  return result\n}\n\nexport function findKey(object, key) {\n  if (key in object) {\n    return object[key]\n  }\n\n  for (const k in object) {\n    const value = object[k]\n    if (typeof value === \"object\") {\n      const result = findKey(value, key)\n      if (typeof result !== \"undefined\") {\n        return result\n      }\n    }\n  }\n}\n\nexport function findKeyWithPath(object, key) {\n  if (key in object) {\n    return {\n      path: key,\n      value: object[key],\n    }\n  }\n\n  for (const k in object) {\n    const value = object[k]\n    if (typeof value === \"object\") {\n      const result = findKey(value, key)\n      if (typeof result.value !== \"undefined\") {\n        return {\n          path: `${k}.${result.path}`,\n          value: result.value,\n        }\n      }\n    }\n  }\n\n  return {\n    path: \"\",\n    value: undefined,\n  }\n}\n\nexport function findAllKeys(object, key) {\n  const result = []\n\n  for (const k in object) {\n    const value = object[k]\n    if (k == key) {\n      result.push(value)\n    }\n    if (typeof value === \"object\") {\n      const r = findAllKeys(value, key)\n      if (r.length > 0) {\n        result.push(...r)\n      }\n    }\n  }\n\n  return result\n}\n\nexport function getByPath(object, path) {\n  const split = path.split(\".\")\n  let obj = object\n  for (const part of split) {\n    obj = obj[part]\n  }\n\n  return obj\n}\n\nexport function transform(object, transformations) {\n  Object.keys(object).forEach((key) => {\n    if (key in transformations) {\n      object[key] = transformations[key].transform(object[key])\n    }\n\n    if (typeof object[key] === \"object\") {\n      transform(object[key], transformations)\n    }\n  })\n}\n\nexport function derToPem(der) {\n  const b64 = Buffer.from(der).toString(\"base64\")\n\n  let withBreaks = \"\"\n  for (let i = 0; i < b64.length; ++i) {\n    withBreaks += i % 64 === 0 ? `\\r\\n${b64[i]}` : b64[i]\n  }\n\n  return (\n    \"-----BEGIN CERTIFICATE-----\" +\n    `${withBreaks}\\r\\n` +\n    \"-----END CERTIFICATE-----\"\n  )\n}\n\nexport function prettyStringify(object) {\n  return JSON.stringify(object, null, 2)\n}\n\nexport function x5cArrayToCertInfo(array) {\n  const info = []\n  for (const x5c of array) {\n    const buffer = x5c.buffer.slice(\n      x5c.byteOffset,\n      x5c.byteOffset + x5c.byteLength\n    )\n    const parsed = fromBER(buffer)\n    const cert = new Certificate({ schema: parsed.result })\n    const slice = {\n      version: cert.version,\n      serialNumber: Buffer.from(cert.serialNumber.valueBlock.valueHex).toString(\n        \"hex\"\n      ),\n      signature: {\n        algorithmId: oids[cert.signature.algorithmId],\n        value: Buffer.from(cert.signatureValue.valueBlock.valueHex).toString(\n          \"hex\"\n        ),\n      },\n      issuer: cert.issuer.typesAndValues[0].value.valueBlock.value,\n      notBefore: cert.notBefore.value,\n      notAfter: cert.notAfter.value,\n      subject: cert.subject.typesAndValues.map((v) => v.value.valueBlock.value),\n      subjectPublicKeyInfo: cert.subjectPublicKeyInfo,\n    }\n    info.push(prettyStringify(slice))\n  }\n\n  return info.join(\"\\n\")\n}\n\nexport const cborEncoder = new cbor.Encoder({\n  genTypes: [\n    ArrayBuffer,\n    (encoder, arrayBuffer) => {\n      return encoder.pushAny(Buffer.from(arrayBuffer))\n    },\n  ],\n})\n\nexport function getErrorMessage(e) {\n  if (e instanceof Error) {\n    return e.toString()\n  }\n\n  return JSON.stringify(e, null, 2)\n}\n\nexport function getSelectValue(select) {\n  return select.options[select.selectedIndex].value\n}\n","import { deepClone, objectSlice, transform, prettyStringify } from \"./utils.js\"\n\nimport { prettifyTransformations } from \"./transformations.js\"\n\nimport cbor from \"cbor\"\nimport log from \"loglevel\"\n\nexport function parseAuthenticatorData(data) {\n  const d =\n    data instanceof ArrayBuffer\n      ? new DataView(data)\n      : new DataView(data.buffer, data.byteOffset, data.byteLength)\n  let p = 0\n\n  const result = {}\n\n  result.rpIdHash = \"\"\n  for (const end = p + 32; p < end; ++p) {\n    result.rpIdHash += d.getUint8(p).toString(16)\n  }\n\n  const flags = d.getUint8(p++)\n  result.flags = {\n    userPresent: (flags & 0x01) !== 0,\n    reserved1: (flags & 0x02) !== 0,\n    userVerified: (flags & 0x04) !== 0,\n    reserved2: ((flags & 0x38) >>> 3).toString(16),\n    attestedCredentialData: (flags & 0x40) !== 0,\n    extensionDataIncluded: (flags & 0x80) !== 0,\n  }\n\n  result.signCount = d.getUint32(p, false)\n  p += 4\n\n  if (result.flags.attestedCredentialData) {\n    const atCredData = {}\n    result.attestedCredentialData = atCredData\n\n    atCredData.aaguid = \"\"\n    for (const end = p + 16; p < end; ++p) {\n      atCredData.aaguid += d.getUint8(p).toString(16)\n    }\n\n    atCredData.credentialIdLength = d.getUint16(p, false)\n    p += 2\n\n    atCredData.credentialId = \"\"\n    for (const end = p + atCredData.credentialIdLength; p < end; ++p) {\n      atCredData.credentialId += d.getUint8(p).toString(16)\n    }\n\n    try {\n      const encodedCred = Buffer.from(d.buffer, d.byteOffset + p)\n      atCredData.credentialPublicKey = cbor.encode(\n        cbor.decodeFirstSync(encodedCred)\n      )\n    } catch (e) {\n      log.error(\"Failed to decode CBOR data: \", e)\n\n      atCredData.credentialPublicKey = `Decode error: ${e.toString()}`\n    }\n  }\n\n  if (result.flags.extensionDataIncluded) {\n    // TODO\n  }\n\n  return result\n}\n\nexport function parseAttestationObject(data) {\n  const buffer =\n    data instanceof ArrayBuffer\n      ? Buffer.from(data)\n      : Buffer.from(data.buffer, data.byteOffset, data.byteLength)\n\n  try {\n    const decoded = cbor.decodeFirstSync(buffer)\n\n    if (decoded.authData) {\n      decoded.authData = parseAuthenticatorData(decoded.authData)\n    }\n\n    return decoded\n  } catch (e) {\n    const msg = \"Failed to decode attestationObject, unknown attestation type?\"\n    log.error(msg)\n    return msg\n  }\n}\n\nexport function parseClientDataJSON(data) {\n  const decoder = new TextDecoder(\"utf-8\")\n  const decoded = decoder.decode(data)\n  return JSON.parse(decoded)\n}\n\nexport function parseCredentials(credentials) {\n  const result = deepClone(credentials)\n  const transformations = objectSlice(prettifyTransformations, [\n    \"clientDataJSON\",\n    \"authenticatorData\",\n    \"attestationObject\",\n  ])\n\n  transform(result, transformations)\n  return result\n}\n\nexport function prettifyCredentials(credentials) {\n  const creds = deepClone(credentials)\n  transform(creds, prettifyTransformations)\n  return splitCredentialsByType(creds)\n}\n\nexport function addMarkupToLine(line) {\n  const separator = line.indexOf(\":\")\n  const head = line.substring(0, separator)\n  const tail = line.substr(separator)\n\n  if (separator < 0) {\n    return line\n  }\n\n  if (tail === \": {\") {\n    return `<span class=\"output-key\">${head}</span>${tail}`\n  }\n\n  return `<span class=\"output-key\">${head}</span><span class=\"output-value\">${tail}</span>`\n}\n\nexport function splitCredentialsByType(credentials) {\n  let cred = `<code class=\"output-section\"><pre>rawId: ${credentials.rawId}\\nid: ${credentials.id}\\ntype: ${credentials.type}\\n</pre></code>\\n<div class=\"output-section output-section-transparent\">response: {</div>`\n\n  if (credentials.clientDataJSON && credentials.signature) {\n    cred += `\\n\\n<code class=\"output-section output-section-turqoise\"><pre>signature: ${\n      credentials.signature\n    }\\n</pre>\n      <pre>userHandle: ${credentials.userHandle}\\n</pre>\n      <pre>clientDataJSON: ${prettyStringify(\n        credentials.clientDataJSON\n      )}</pre></code>`\n  } else if (credentials.clientDataJSON) {\n    cred += `<code class=\"output-section output-section-turqoise\"><pre>clientDataJSON: ${prettyStringify(\n      credentials.clientDataJSON\n    )}</pre></code>`\n  }\n\n  if (credentials.attestationObject) {\n    cred += `<code class=\"output-section output-section-green\"><pre>attestationObject: ${prettyStringify(\n      credentials.attestationObject\n    )}</pre></code>`\n  }\n\n  if (credentials.authenticatorData) {\n    cred += `<code class=\"output-section output-section-green\"><pre>authenticatorData: ${prettyStringify(\n      credentials.authenticatorData\n    )}</pre></code>`\n  }\n\n  cred += `<div class=\"output-section output-section-transparent\">}</div>`\n\n  return cred\n}\n\nexport function orderCredentialsByType(credentials) {\n  const orderedCredentials = {\n    rawId: credentials.rawId,\n    id: credentials.id,\n    type: credentials.type,\n    clientDataJSON: credentials.response.clientDataJSON,\n  }\n\n  if (credentials.response.attestationObject) {\n    orderedCredentials.attestationObject =\n      credentials.response.attestationObject\n  }\n\n  if (credentials.response.authenticatorData) {\n    orderedCredentials.authenticatorData =\n      credentials.response.authenticatorData\n  }\n\n  if (credentials.response.signature) {\n    orderedCredentials.signature = credentials.response.signature\n  }\n\n  if (credentials.response.userHandle) {\n    orderedCredentials.userHandle = credentials.response.userHandle\n  }\n\n  return orderedCredentials\n}\n\nexport function prettyCredentialsWithHtml(prettyCredentials) {\n  let lines = prettyCredentials.split(\"\\n\")\n\n  lines = lines.map((line) => {\n    for (const key of Object.keys(prettifyTransformations)) {\n      const keyStr = `\"${key}\": `\n      const idx = line.indexOf(keyStr)\n      if (idx !== -1 && prettifyTransformations[key].buttons) {\n        const pos = idx + keyStr.length\n\n        const head = line.substring(0, pos)\n        const tail = line.substring(pos)\n\n        let buttons = \"\"\n        for (const but of prettifyTransformations[key].buttons) {\n          buttons +=\n            `<button class=\"button hide-mobile\" data-key=\"${key}\" onclick=\"outputButtonClick(event);\">` +\n            `${but}</button>`\n        }\n        line = `${head}${buttons} ${tail}`\n      }\n    }\n\n    return addMarkupToLine(line)\n  })\n  return lines.join(\"\\n\")\n}\n","import {\n  parseAuthenticatorData,\n  parseAttestationObject,\n  parseClientDataJSON\n} from './output-parser';\n\nimport coseToJwk from 'cose-to-jwk';\n\nexport function binToHex(data) {\n  if(!(data instanceof Buffer)) {\n    try {\n      data = Buffer.from(data);\n    } catch(e) {\n      return '';\n    }\n  }\n\n  return data.toString('hex');\n}\n\nexport const prettifyTransformations = {\n  rawId: {\n    transform: binToHex,\n    buttons: ['Use', 'Download']\n  },\n  sig: {\n    transform: binToHex,\n    buttons: ['Download']\n  },\n  signature: {\n    transform: binToHex,\n    buttons: ['Download']\n  },\n  userHandle: {\n    transform: binToHex,\n    buttons: ['Download']\n  },\n  x5c: {\n    transform: arr => arr.map(binToHex),\n    buttons: ['View', 'Download PEM']\n  },\n  credentialPublicKey: {\n    transform: coseToJwk,\n    buttons: ['Download COSE', 'Download JWK', 'Download PEM']\n  },\n  authenticatorData: {\n    transform: parseAuthenticatorData\n  },\n  attestationObject: {\n    transform: parseAttestationObject\n  },\n  clientDataJSON: {\n    transform: parseClientDataJSON\n  },\n};\n","import base64url from \"base64url\"\n/**\n * Converts PublicKeyCredential into serialised JSON\n * @param  {Object} pubKeyCred\n * @return {Object}            - JSON encoded publicKeyCredential\n */\nexport function publicKeyCredentialToJSON(pubKeyCred) {\n  if (pubKeyCred instanceof Array) {\n    let arr = []\n    for (let i of pubKeyCred) arr.push(publicKeyCredentialToJSON(i))\n\n    return arr\n  }\n\n  if (pubKeyCred instanceof ArrayBuffer) {\n    return base64url.encode(pubKeyCred)\n  }\n\n  if (pubKeyCred instanceof Object) {\n    let obj = {}\n\n    for (let key in pubKeyCred) {\n      obj[key] = publicKeyCredentialToJSON(pubKeyCred[key])\n    }\n\n    return obj\n  }\n\n  return pubKeyCred\n}\n\n/**\n * Generate secure random buffer\n * @param  {Number} len - Length of the buffer (default 32 bytes)\n * @return {Uint8Array} - random string\n */\nexport function generateRandomBuffer(len) {\n  len = len || 32\n\n  let randomBuffer = new Uint8Array(len)\n  window.crypto.getRandomValues(randomBuffer)\n\n  return randomBuffer\n}\n\n/**\n * Decodes arrayBuffer required fields.\n */\nexport function preformatMakeCredReq(makeCredReq) {\n  makeCredReq.challenge = Base64Decode(makeCredReq.challenge)\n  makeCredReq.user.id = Base64Decode(makeCredReq.user.id)\n\n  return makeCredReq\n}\n\n/**\n * Decodes arrayBuffer required fields.\n */\nexport function preformatGetAssertReq(getAssert) {\n  getAssert.challenge = Base64Decode(getAssert.challenge)\n\n  for (let allowCred of getAssert.allowCredentials) {\n    allowCred.id = Base64Decode(allowCred.id)\n  }\n\n  return getAssert\n}\n\nexport function Base64Encode(arraybuffer) {\n  let chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"\n\n  // Use a lookup table to find the index.\n  let lookup = new Uint8Array(256)\n  for (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i\n  }\n\n  let bytes = new Uint8Array(arraybuffer),\n    i,\n    len = bytes.length,\n    base64url = \"\"\n\n  for (i = 0; i < len; i += 3) {\n    base64url += chars[bytes[i] >> 2]\n    base64url += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)]\n    base64url += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)]\n    base64url += chars[bytes[i + 2] & 63]\n  }\n\n  if (len % 3 === 2) {\n    base64url = base64url.substring(0, base64url.length - 1)\n  } else if (len % 3 === 1) {\n    base64url = base64url.substring(0, base64url.length - 2)\n  }\n\n  return base64url\n}\n\nexport function Base64Decode(base64string) {\n  let chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"\n\n  // Use a lookup table to find the index.\n  let lookup = new Uint8Array(256)\n  for (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i\n  }\n\n  let bufferLength = base64string.length * 0.75,\n    len = base64string.length,\n    i,\n    p = 0,\n    encoded1,\n    encoded2,\n    encoded3,\n    encoded4\n\n  let bytes = new Uint8Array(bufferLength)\n\n  for (i = 0; i < len; i += 4) {\n    encoded1 = lookup[base64string.charCodeAt(i)]\n    encoded2 = lookup[base64string.charCodeAt(i + 1)]\n    encoded3 = lookup[base64string.charCodeAt(i + 2)]\n    encoded4 = lookup[base64string.charCodeAt(i + 3)]\n\n    bytes[p++] = (encoded1 << 2) | (encoded2 >> 4)\n    bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2)\n    bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63)\n  }\n\n  return bytes.buffer\n}\n"],"sourceRoot":""}